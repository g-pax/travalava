name: lighthouse

on:
  pull_request:
    branches: ["main"]
    types: [opened, synchronize, reopened]

jobs:
  lhci:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      statuses: write
      actions: read         # <-- needed to list artifacts

    env:
      NEXT_TELEMETRY_DISABLED: "1"
      NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
      NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
      NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
      NEXT_PUBLIC_GOOGLE_MAPS_API_KEY: ${{ secrets.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY }}
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET: ${{ secrets.R2_BUCKET }}
      NEXT_PUBLIC_R2_PUBLIC_URL: ${{ secrets.NEXT_PUBLIC_R2_PUBLIC_URL }}
      GOOGLE_PLACES_API_KEY: ${{ secrets.GOOGLE_PLACES_API_KEY }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"

      - name: Install deps
        run: npm ci

      # Optional sanity check: ensure the app actually starts before LHCI
      - name: Build app
        run: npm run build

      - name: Start app in background
        run: |
          npx next start -p 3000 -H 127.0.0.1 & \
          npx --yes wait-on http://127.0.0.1:3000

      - name: Run Lighthouse CI
        run: npx lhci collect --config=./lighthouserc.json && npx lhci assert --config=./lighthouserc.json

      - name: Upload HTML reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-report
          path: .lighthouseci/*.html
  
      - name: Summarize Lighthouse scores
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const manifestPath = '.lighthouseci/manifest.json';
          const m = JSON.parse(fs.readFileSync(manifestPath,'utf8'));
          const byUrl = {};
          for (const r of m) byUrl[r.url] = r;
          const rows = [];
          const pct = v => Math.round(v*100);
          for (const [url, r] of Object.entries(byUrl)) {
            const s = r.summary;
            const reportFile = r.htmlPath ? path.basename(r.htmlPath) : '';
            rows.push(`| ${url} | ${pct(s.performance)} | ${pct(s.accessibility)} | ${pct(s.seo)} | ${pct(s['best-practices']||0)} | ${reportFile} |`);
          }
          const md = [
            '## Lighthouse summary',
            '',
            '| Page | Perf | A11y | SEO | Best-practices | Report file |',
            '|---|---:|---:|---:|---:|---|',
            ...rows
          ].join('\n');
          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, md + '\n');
          NODE

      - name: Comment results on PR (with artifact link)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync(process.env.GITHUB_STEP_SUMMARY, 'utf8');

            const {owner, repo} = context.repo;
            const run_id = context.runId;

            // List artifacts for this workflow run
            const { data } = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
            const artifact = data.artifacts.find(a => a.name === 'lighthouse-report');

            // Build artifact page link if found
            const artifactLink = artifact
              ? `üîó **HTML reports:** https://github.com/${owner}/${repo}/actions/runs/${run_id}/artifacts/${artifact.id}`
              : '‚ö†Ô∏è Artifact not found. Check the workflow logs!';

            const body = `<!-- lhci-summary -->\n${summary}\n\n${artifactLink}`;

            // Upsert sticky comment
            const pr = context.payload.pull_request.number;
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: pr });
            const existing = comments.find(c => c.body && c.body.includes('<!-- lhci-summary -->'));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr, body });
            }
